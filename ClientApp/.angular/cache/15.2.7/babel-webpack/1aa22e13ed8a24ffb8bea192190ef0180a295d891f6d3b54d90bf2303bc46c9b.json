{"ast":null,"code":"import _asyncToGenerator from \"D:/project angular/Student_Task_Tracker/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, ViewChild, Component, Output, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n\n/**\n * EXIF tag standard reference\n *\n * Tag Name: Orientation\n * Tag ID: 0x0112\n * Writable: int16u\n * Group: IFD0\n * Values:\n 1 = Horizontal (normal)\n 2 = Mirror horizontal\n 3 = Rotate 180\n 4 = Mirror vertical\n 5 = Mirror horizontal and rotate 270 CW\n 6 = Rotate 90 CW\n 7 = Mirror horizontal and rotate 90 CW\n 8 = Rotate 270 CW\n */\nconst _c0 = [\"video\"];\nfunction NgxImageCaptureComponent_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 2);\n    i0.ɵɵlistener(\"click\", function NgxImageCaptureComponent_span_0_Template_span_click_0_listener() {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r3 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r3.startVideoCapture());\n    });\n    i0.ɵɵprojection(1);\n    i0.ɵɵelementEnd();\n  }\n}\nfunction NgxImageCaptureComponent_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 2);\n    i0.ɵɵlistener(\"click\", function NgxImageCaptureComponent_span_1_Template_span_click_0_listener() {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r5.acquireImage());\n    });\n    i0.ɵɵprojection(1, 1);\n    i0.ɵɵelementEnd();\n  }\n}\nfunction NgxImageCaptureComponent_video_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"video\", 3, 4);\n  }\n}\nconst _c1 = [[[\"\", \"openStreamBtn\", \"\"]], [[\"\", \"acquireImageBtn\", \"\"]]];\nconst _c2 = [\"[openStreamBtn]\", \"[acquireImageBtn]\"];\nvar DOC_ORIENTATION;\n(function (DOC_ORIENTATION) {\n  DOC_ORIENTATION[DOC_ORIENTATION[\"Up\"] = 1] = \"Up\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"Down\"] = 3] = \"Down\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"Right\"] = 6] = \"Right\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"Left\"] = 8] = \"Left\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"UpMirrored\"] = 2] = \"UpMirrored\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"DownMirrored\"] = 4] = \"DownMirrored\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"LeftMirrored\"] = 5] = \"LeftMirrored\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"RightMirrored\"] = 7] = \"RightMirrored\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"Default\"] = 0] = \"Default\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"NotJpeg\"] = -1] = \"NotJpeg\";\n  DOC_ORIENTATION[DOC_ORIENTATION[\"NotDefined\"] = -2] = \"NotDefined\";\n})(DOC_ORIENTATION || (DOC_ORIENTATION = {}));\nvar _a;\nclass ImageCompress {}\n_a = ImageCompress;\nImageCompress.getOrientation = file => new Promise((resolve, reject) => {\n  try {\n    const reader = new FileReader();\n    reader.onload = () => {\n      const view = new DataView(reader.result);\n      if (!view.byteLength) {\n        return resolve(DOC_ORIENTATION.NotDefined);\n      }\n      if (view.getUint16(0, false) !== 0xffd8) {\n        return resolve(DOC_ORIENTATION.NotDefined);\n      }\n      const length = view.byteLength;\n      let offset = 2;\n      while (offset < length) {\n        const marker = view.getUint16(offset, false);\n        offset += 2;\n        if (marker === 0xffe1) {\n          if (view.getUint32(offset += 2, false) !== 0x45786966) {\n            return resolve(DOC_ORIENTATION.NotJpeg);\n          }\n          const little = view.getUint16(offset += 6, false) === 0x4949;\n          offset += view.getUint32(offset + 4, little);\n          const tags = view.getUint16(offset, little);\n          offset += 2;\n          for (let i = 0; i < tags; i++) {\n            if (view.getUint16(offset + i * 12, little) === 0x0112) {\n              return resolve(view.getUint16(offset + i * 12 + 8, little));\n            }\n          }\n        } else if ((marker & 0xff00) !== 0xff00) {\n          break;\n        } else {\n          offset += view.getUint16(offset, false);\n        }\n      }\n      return resolve(DOC_ORIENTATION.NotJpeg);\n    };\n    reader.readAsArrayBuffer(file);\n  } catch (e) {\n    return reject(DOC_ORIENTATION.Default);\n  }\n});\nImageCompress.uploadFile = (render, multiple = true, rejectOnCancel = false) => new Promise(function (resolve, reject) {\n  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  const isIOS = /iPad|iPhone|iPod/i.test(navigator.userAgent);\n  Promise.resolve(isSafari || isIOS).then(onlyNative => {\n    if (onlyNative) {\n      return ImageCompress.generateUploadInputNative(window.document, multiple, rejectOnCancel);\n    } else {\n      return ImageCompress.generateUploadInputRenderer(render, multiple, rejectOnCancel);\n    }\n  }).then(filesList => {\n    const files = filesList ? Array.from(filesList) : [];\n    const orientationPromises = files.map(file => ImageCompress.getOrientation(file));\n    const readerPromises = files.map(file => ImageCompress.fileToDataURL(file));\n    let orientationsResult = [];\n    Promise.all(orientationPromises).then(orientations => {\n      orientationsResult = orientations;\n      return Promise.all(readerPromises);\n    }).then(readerResult => {\n      const resultArray = readerResult.map((parsedFile, index) => ({\n        image: parsedFile.dataUrl,\n        orientation: orientationsResult[index],\n        fileName: parsedFile.fileName\n      }));\n      if (multiple) {\n        resolve(resultArray);\n      } else {\n        resolve(resultArray[0]);\n      }\n    });\n  }).catch(err => reject(err));\n});\nImageCompress.fileToDataURL = file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      //myReader.onloadend = (progressEvent: ProgressEvent<FileReader>)\n      resolve({\n        dataUrl: e.target.result,\n        fileName: file.name\n      });\n    };\n    try {\n      reader.readAsDataURL(file);\n    } catch (e) {\n      reject(`ngx-image-compress - probably no file have been selected: ${e}`);\n    }\n  });\n};\nImageCompress.generateUploadInputRenderer = (render, multiple = true, rejectOnCancel = false) => {\n  let lock = false;\n  return new Promise((resolve, reject) => {\n    const inputElement = render.createElement('input');\n    render.setStyle(inputElement, 'display', 'none');\n    render.setProperty(inputElement, 'type', 'file');\n    render.setProperty(inputElement, 'accept', 'image/*');\n    if (multiple) {\n      render.setProperty(inputElement, 'multiple', 'true');\n    }\n    render.listen(inputElement, 'click', $event => {\n      $event.target.value = '';\n    });\n    render.listen(inputElement, 'change', $event => {\n      lock = true;\n      const files = $event.target.files;\n      resolve(files);\n    });\n    if (rejectOnCancel) {\n      window.addEventListener('focus', () => {\n        setTimeout(() => {\n          if (!lock) {\n            reject(new Error('file upload on blur - no file selected'));\n          }\n        }, 300);\n      }, {\n        once: true\n      });\n    }\n    inputElement.click();\n  });\n};\nImageCompress.generateUploadInputNative = (documentNativeApi, multiple = true, rejectOnCancel = false) => {\n  let lock = false;\n  return new Promise((resolve, reject) => {\n    const inputElement = documentNativeApi.createElement('input');\n    inputElement.id = 'upload-input' + new Date();\n    inputElement.style.display = 'none';\n    inputElement.setAttribute('type', 'file');\n    inputElement.setAttribute('accept', 'image/*');\n    if (multiple) {\n      inputElement.setAttribute('multiple', 'true');\n    }\n    documentNativeApi.body.appendChild(inputElement);\n    inputElement.addEventListener('change', () => {\n      lock = true;\n      resolve(inputElement.files);\n      documentNativeApi.body.removeChild(documentNativeApi.getElementById(inputElement.id));\n    }, {\n      once: true\n    });\n    if (rejectOnCancel) {\n      window.addEventListener('focus', () => {\n        setTimeout(() => {\n          if (!lock && documentNativeApi.getElementById(inputElement.id)) {\n            reject(new Error('file upload on blur - no file selected'));\n            documentNativeApi.body.removeChild(documentNativeApi.getElementById(inputElement.id));\n          }\n        }, 300);\n      }, {\n        once: true\n      });\n    }\n    // open file select box\n    inputElement.click();\n  });\n};\nImageCompress.compress = (imageDataUrlSource, orientation, render, ratio = 50, quality = 50, maxwidth = 0, maxheight = 0) => new Promise(function (resolve, reject) {\n  quality = quality / 100;\n  ratio = ratio / 100;\n  const sourceImage = new Image();\n  // important for safari: we need to wait for onload event\n  sourceImage.onload = () => {\n    const canvas = render.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      return reject(`No canvas context available`);\n    }\n    let w = sourceImage.naturalWidth;\n    let h = sourceImage.naturalHeight;\n    if (!CSS.supports('image-orientation', 'from-image')) {\n      if (orientation === DOC_ORIENTATION.Right || orientation === DOC_ORIENTATION.Left) {\n        const t = w;\n        w = h;\n        h = t;\n      }\n    }\n    const xratio = maxwidth ? maxwidth / w : 1;\n    const yratio = maxheight ? maxheight / h : 1;\n    ratio = Math.min(ratio, xratio, yratio);\n    canvas.width = w * ratio;\n    canvas.height = h * ratio;\n    const TO_RADIANS = Math.PI / 180;\n    if (CSS.supports('image-orientation', 'from-image') || orientation === DOC_ORIENTATION.Up) {\n      ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n    } else if (orientation === DOC_ORIENTATION.Right) {\n      ctx.save();\n      ctx.rotate(90 * TO_RADIANS);\n      ctx.translate(0, -canvas.width);\n      ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n      ctx.restore();\n    } else if (orientation === DOC_ORIENTATION.Left) {\n      ctx.save();\n      ctx.rotate(-90 * TO_RADIANS);\n      ctx.translate(-canvas.width, 0);\n      ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n      ctx.restore();\n    } else if (orientation === DOC_ORIENTATION.Down) {\n      ctx.save();\n      ctx.rotate(180 * TO_RADIANS);\n      ctx.translate(-canvas.width, -canvas.height);\n      ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n      ctx.restore();\n    } else {\n      // no orientation value found - same as default UP\n      ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n    }\n    const mime = imageDataUrlSource.substr(5, imageDataUrlSource.split(';')[0].length - 5);\n    // TODO test on mime\n    const result = canvas.toDataURL(mime, quality);\n    resolve(result);\n  };\n  sourceImage.onerror = e => reject(e);\n  sourceImage.src = imageDataUrlSource;\n});\nImageCompress.byteCount = imgString => encodeURI(imgString).split(/%..|./).length - 1;\nImageCompress.getImageMaxSize = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (maxSizeMb, debugMode, render, rejectOnCancel = false) {\n    const MAX_TRIES = 10;\n    const bytesToMB = bytes => (bytes / 1024 / 1024).toFixed(2);\n    if (debugMode) {\n      console.debug('NgxImageCompress - Opening upload window');\n    }\n    const myFile = yield ImageCompress.uploadFile(render, false, rejectOnCancel);\n    let compressedFile;\n    for (let i = 0; i < MAX_TRIES; i++) {\n      const previousSize = ImageCompress.byteCount(myFile.image);\n      compressedFile = yield ImageCompress.compress(myFile.image, myFile.orientation, render, 50, 100);\n      const newSize = ImageCompress.byteCount(compressedFile);\n      console.debug('NgxImageCompress -', 'Compression from', bytesToMB(previousSize), 'MB to', bytesToMB(newSize), 'MB');\n      if (newSize >= previousSize) {\n        if (i === 0) {\n          if (debugMode) {\n            console.debug('NgxImageCompress -', \"File can't be reduced at all - returning the original\", bytesToMB(previousSize), 'MB large');\n          }\n          throw {\n            ...myFile,\n            image: compressedFile\n          };\n        } else {\n          if (debugMode) {\n            console.debug('NgxImageCompress -', \"File can't be reduced more - returning the best we can, which is \", bytesToMB(previousSize), 'MB large');\n          }\n          throw {\n            ...myFile,\n            image: compressedFile\n          };\n        }\n      } else {\n        if (newSize < maxSizeMb * 1024 * 1024) {\n          if (debugMode) {\n            console.debug('NgxImageCompress -', 'Here your file', bytesToMB(newSize), 'MB large');\n          }\n          return {\n            ...myFile,\n            image: compressedFile\n          };\n        } else if (i === 9) {\n          if (debugMode) {\n            console.debug('NgxImageCompress -', \"File can't reach the desired size after\", MAX_TRIES, 'tries. Returning file ', bytesToMB(previousSize), 'MB large');\n          }\n          throw {\n            ...myFile,\n            image: compressedFile\n          };\n        }\n      }\n      if (debugMode) {\n        console.debug('NgxImageCompress -', 'Reached', bytesToMB(newSize), 'MB large. Trying another time after', i + 1, 'times');\n      }\n      myFile.image = compressedFile;\n    }\n    if (debugMode) {\n      console.debug('NgxImageCompress - Unexpected error');\n    }\n    throw {};\n  });\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nclass NgxImageCompressService {\n  constructor(rendererFactory) {\n    this.DOC_ORIENTATION = DOC_ORIENTATION;\n    this.render = rendererFactory.createRenderer(null, null);\n  }\n  /**\n   * helper to evaluate the compression rate\n   * @param imgString the image in base64 string format\n   */\n  byteCount(image) {\n    return ImageCompress.byteCount(image);\n  }\n  /**\n   * Get the correct Orientation value from image tags\n   */\n  getOrientation(file) {\n    return ImageCompress.getOrientation(file);\n  }\n  /**\n   * return a promise with the new image data and image orientation\n   * Nothing happen if no file have been selected\n   */\n  uploadFile() {\n    return ImageCompress.uploadFile(this.render, false);\n  }\n  /**\n   * return a promise with an array of image data and image orientation\n   * Nothing happen if no files have been selected\n   */\n  uploadMultipleFiles() {\n    return ImageCompress.uploadFile(this.render, true);\n  }\n  /**\n   * return a promise with the new image data and image orientation\n   * the promise will reject if no file have been selected\n   */\n  uploadFileOrReject() {\n    return ImageCompress.uploadFile(this.render, false, true);\n  }\n  /**\n   * return a promise with an array of image data and image orientation\n   * the promise will reject if no files have been selected\n   */\n  uploadMultipleFilesOrReject() {\n    return ImageCompress.uploadFile(this.render, true, true);\n  }\n  /**\n  * perform a compression from the given DataUrl (string), provided by the uploadFile, or uploadMultipleFiles method\n  *\n  *\n  | Parameter   | Type   | Description                                                                       |\n  | ----------- | ------ | --------------------------------------------------------------------------------- |\n  | image       | string | DataUrl (string) representing the image                                           |\n  | orientation | number | EXIF Orientation value using the DOC_ORIENTATION enum value                       |\n  | ratio       | number | Maximum scale factor as a percentage (optional, default: 50) <sup>[1](#fn1)</sup> |\n  | quality     | number | JPEG quality factor as a percentage (optional, default: 50) <sup>[2](#fn2)</sup>  |\n  | maxwidth    | number | Maximum width in pixels if you need to resize (optional, default: 0 - no resize)  |\n  | maxheight   | number | Maximum height in pixels if you need to resize (optional, default: 0 - no resize) |\n  */\n  compressFile(image, orientation, ratio = 50, quality = 50, maxWidth = 0, maxHeight = 0) {\n    return ImageCompress.compress(image, orientation, this.render, ratio, quality, maxWidth, maxHeight);\n  }\n  /**\n   * Most simple function to use here.\n   * Perform an upload and return an image dataUrl (string format) with a maximum size, given in *MegaBytes*\n   * If the size can't be reached, the best that can be reached will be returned in promise *rejection*\n   * Put debugMode to true if you have some trouble to print some help using console.debug\n   */\n  uploadAndGetImageWithMaxSize(maxSizeMb = 1, debugMode = false, rejectOnCancel = false) {\n    return ImageCompress.getImageMaxSize(maxSizeMb, debugMode, this.render, rejectOnCancel).then(uploadResponse => uploadResponse.image).catch(e => {\n      throw e.image;\n    });\n  }\n  /**\n   * Same as before, but return more informations (file name...)\n   */\n  uploadAndGetImageWithMaxSizeAndMetas(maxSizeMb = 1, debugMode = false, rejectOnCancel = false) {\n    return ImageCompress.getImageMaxSize(maxSizeMb, debugMode, this.render, rejectOnCancel);\n  }\n}\nNgxImageCompressService.ɵfac = function NgxImageCompressService_Factory(t) {\n  return new (t || NgxImageCompressService)(i0.ɵɵinject(i0.RendererFactory2));\n};\nNgxImageCompressService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxImageCompressService,\n  factory: NgxImageCompressService.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxImageCompressService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.RendererFactory2\n    }];\n  }, null);\n})();\nclass NgxImageCaptureComponent {\n  constructor() {\n    this.imageCaptured = new EventEmitter();\n    this.errorCapture = new EventEmitter();\n    this.videoElement = null;\n    this.videoStream = ViewChild('video');\n    this.streamOpened = false;\n  }\n  startVideoCapture() {\n    this.streamOpened = true;\n    const constraints = {\n      audio: false,\n      video: {\n        width: {\n          ideal: 1920\n        },\n        height: {\n          ideal: 1080\n        },\n        facingMode: {\n          ideal: 'user'\n        }\n      }\n    };\n    navigator.mediaDevices.getUserMedia(constraints).then(stream => {\n      this.videoStream = stream;\n      setTimeout(() => {\n        if (this.videoElement?.nativeElement) {\n          this.videoElement.nativeElement.srcObject = stream;\n        }\n      }, 100);\n    }).catch(error => {\n      this.errorCapture.emit(`Ngx Image Compress: Could not access the camera. ${error}`);\n      this.streamOpened = true;\n    });\n  }\n  acquireImage() {\n    const canvas = document.createElement('canvas');\n    const video = this.videoElement?.nativeElement;\n    if (!video) {\n      this.errorCapture.emit('Ngx Image Compress - Error in acquisition of video element.');\n      this.streamOpened = false;\n      return;\n    }\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n    canvas.getContext('2d')?.drawImage(video, 0, 0);\n    const newImage = canvas.toDataURL('jpg', 95);\n    if (this.videoStream) {\n      this.videoStream.getVideoTracks().forEach(track => track.stop());\n    }\n    this.imageCaptured.emit(newImage);\n    this.streamOpened = false;\n  }\n}\nNgxImageCaptureComponent.ɵfac = function NgxImageCaptureComponent_Factory(t) {\n  return new (t || NgxImageCaptureComponent)();\n};\nNgxImageCaptureComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: NgxImageCaptureComponent,\n  selectors: [[\"ngx-image-capture\"]],\n  viewQuery: function NgxImageCaptureComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 5);\n    }\n    if (rf & 2) {\n      let _t;\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.videoElement = _t.first);\n    }\n  },\n  outputs: {\n    imageCaptured: \"imageCaptured\",\n    errorCapture: \"errorCapture\"\n  },\n  ngContentSelectors: _c2,\n  decls: 3,\n  vars: 3,\n  consts: [[3, \"click\", 4, \"ngIf\"], [\"autoplay\", \"\", 4, \"ngIf\"], [3, \"click\"], [\"autoplay\", \"\"], [\"video\", \"\"]],\n  template: function NgxImageCaptureComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef(_c1);\n      i0.ɵɵtemplate(0, NgxImageCaptureComponent_span_0_Template, 2, 0, \"span\", 0);\n      i0.ɵɵtemplate(1, NgxImageCaptureComponent_span_1_Template, 2, 0, \"span\", 0);\n      i0.ɵɵtemplate(2, NgxImageCaptureComponent_video_2_Template, 2, 0, \"video\", 1);\n    }\n    if (rf & 2) {\n      i0.ɵɵproperty(\"ngIf\", !ctx.streamOpened);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngIf\", ctx.streamOpened);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngIf\", ctx.streamOpened);\n    }\n  },\n  dependencies: [i1.NgIf],\n  encapsulation: 2\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxImageCaptureComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-image-capture',\n      template: `\n        <span (click)=\"startVideoCapture()\" *ngIf=\"!streamOpened\">\n            <ng-content select=\"[openStreamBtn]\"></ng-content>\n        </span>\n        <span (click)=\"acquireImage()\" *ngIf=\"streamOpened\">\n            <ng-content select=\"[acquireImageBtn]\"></ng-content>\n        </span>\n        <video #video autoplay *ngIf=\"streamOpened\"></video>\n    `\n    }]\n  }], null, {\n    imageCaptured: [{\n      type: Output\n    }],\n    errorCapture: [{\n      type: Output\n    }],\n    videoElement: [{\n      type: ViewChild,\n      args: ['video']\n    }]\n  });\n})();\nclass NgxImageCaptureModule {}\nNgxImageCaptureModule.ɵfac = function NgxImageCaptureModule_Factory(t) {\n  return new (t || NgxImageCaptureModule)();\n};\nNgxImageCaptureModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxImageCaptureModule\n});\nNgxImageCaptureModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [CommonModule]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxImageCaptureModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [NgxImageCaptureComponent],\n      imports: [CommonModule],\n      exports: [NgxImageCaptureComponent]\n    }]\n  }], null, null);\n})();\n\n/*\n * Public API Surface of ngx-image-compress\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DOC_ORIENTATION, NgxImageCaptureComponent, NgxImageCaptureModule, NgxImageCompressService };","map":{"version":3,"names":["i0","Injectable","EventEmitter","ViewChild","Component","Output","NgModule","i1","CommonModule","DOC_ORIENTATION","_a","ImageCompress","getOrientation","file","Promise","resolve","reject","reader","FileReader","onload","view","DataView","result","byteLength","NotDefined","getUint16","length","offset","marker","getUint32","NotJpeg","little","tags","i","readAsArrayBuffer","e","Default","uploadFile","render","multiple","rejectOnCancel","isSafari","test","navigator","userAgent","isIOS","then","onlyNative","generateUploadInputNative","window","document","generateUploadInputRenderer","filesList","files","Array","from","orientationPromises","map","readerPromises","fileToDataURL","orientationsResult","all","orientations","readerResult","resultArray","parsedFile","index","image","dataUrl","orientation","fileName","catch","err","target","name","readAsDataURL","lock","inputElement","createElement","setStyle","setProperty","listen","$event","value","addEventListener","setTimeout","Error","once","click","documentNativeApi","id","Date","style","display","setAttribute","body","appendChild","removeChild","getElementById","compress","imageDataUrlSource","ratio","quality","maxwidth","maxheight","sourceImage","Image","canvas","ctx","getContext","w","naturalWidth","h","naturalHeight","CSS","supports","Right","Left","t","xratio","yratio","Math","min","width","height","TO_RADIANS","PI","Up","drawImage","save","rotate","translate","restore","Down","mime","substr","split","toDataURL","onerror","src","byteCount","imgString","encodeURI","getImageMaxSize","maxSizeMb","debugMode","MAX_TRIES","bytesToMB","bytes","toFixed","console","debug","myFile","compressedFile","previousSize","newSize","NgxImageCompressService","constructor","rendererFactory","createRenderer","uploadMultipleFiles","uploadFileOrReject","uploadMultipleFilesOrReject","compressFile","maxWidth","maxHeight","uploadAndGetImageWithMaxSize","uploadResponse","uploadAndGetImageWithMaxSizeAndMetas","ɵfac","RendererFactory2","ɵprov","type","args","providedIn","NgxImageCaptureComponent","imageCaptured","errorCapture","videoElement","videoStream","streamOpened","startVideoCapture","constraints","audio","video","ideal","facingMode","mediaDevices","getUserMedia","stream","nativeElement","srcObject","error","emit","acquireImage","videoWidth","videoHeight","newImage","getVideoTracks","forEach","track","stop","ɵcmp","NgIf","selector","template","NgxImageCaptureModule","ɵmod","ɵinj","declarations","imports","exports"],"sources":["D:/project angular/Student_Task_Tracker/node_modules/ngx-image-compress/fesm2020/ngx-image-compress.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, ViewChild, Component, Output, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n\n/**\n * EXIF tag standard reference\n *\n * Tag Name: Orientation\n * Tag ID: 0x0112\n * Writable: int16u\n * Group: IFD0\n * Values:\n 1 = Horizontal (normal)\n 2 = Mirror horizontal\n 3 = Rotate 180\n 4 = Mirror vertical\n 5 = Mirror horizontal and rotate 270 CW\n 6 = Rotate 90 CW\n 7 = Mirror horizontal and rotate 90 CW\n 8 = Rotate 270 CW\n */\nvar DOC_ORIENTATION;\n(function (DOC_ORIENTATION) {\n    DOC_ORIENTATION[DOC_ORIENTATION[\"Up\"] = 1] = \"Up\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"Down\"] = 3] = \"Down\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"Right\"] = 6] = \"Right\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"Left\"] = 8] = \"Left\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"UpMirrored\"] = 2] = \"UpMirrored\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"DownMirrored\"] = 4] = \"DownMirrored\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"LeftMirrored\"] = 5] = \"LeftMirrored\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"RightMirrored\"] = 7] = \"RightMirrored\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"Default\"] = 0] = \"Default\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"NotJpeg\"] = -1] = \"NotJpeg\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"NotDefined\"] = -2] = \"NotDefined\";\n})(DOC_ORIENTATION || (DOC_ORIENTATION = {}));\n\nvar _a;\nclass ImageCompress {\n}\n_a = ImageCompress;\nImageCompress.getOrientation = (file) => new Promise((resolve, reject) => {\n    try {\n        const reader = new FileReader();\n        reader.onload = () => {\n            const view = new DataView(reader.result);\n            if (!view.byteLength) {\n                return resolve(DOC_ORIENTATION.NotDefined);\n            }\n            if (view.getUint16(0, false) !== 0xffd8) {\n                return resolve(DOC_ORIENTATION.NotDefined);\n            }\n            const length = view.byteLength;\n            let offset = 2;\n            while (offset < length) {\n                const marker = view.getUint16(offset, false);\n                offset += 2;\n                if (marker === 0xffe1) {\n                    if (view.getUint32((offset += 2), false) !== 0x45786966) {\n                        return resolve(DOC_ORIENTATION.NotJpeg);\n                    }\n                    const little = view.getUint16((offset += 6), false) === 0x4949;\n                    offset += view.getUint32(offset + 4, little);\n                    const tags = view.getUint16(offset, little);\n                    offset += 2;\n                    for (let i = 0; i < tags; i++) {\n                        if (view.getUint16(offset + i * 12, little) === 0x0112) {\n                            return resolve(view.getUint16(offset + i * 12 + 8, little));\n                        }\n                    }\n                }\n                else if ((marker & 0xff00) !== 0xff00) {\n                    break;\n                }\n                else {\n                    offset += view.getUint16(offset, false);\n                }\n            }\n            return resolve(DOC_ORIENTATION.NotJpeg);\n        };\n        reader.readAsArrayBuffer(file);\n    }\n    catch (e) {\n        return reject(DOC_ORIENTATION.Default);\n    }\n});\nImageCompress.uploadFile = (render, multiple = true, rejectOnCancel = false) => new Promise(function (resolve, reject) {\n    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    const isIOS = /iPad|iPhone|iPod/i.test(navigator.userAgent);\n    Promise.resolve(isSafari || isIOS)\n        .then(onlyNative => {\n        if (onlyNative) {\n            return ImageCompress.generateUploadInputNative(window.document, multiple, rejectOnCancel);\n        }\n        else {\n            return ImageCompress.generateUploadInputRenderer(render, multiple, rejectOnCancel);\n        }\n    })\n        .then((filesList) => {\n        const files = filesList ? Array.from(filesList) : [];\n        const orientationPromises = files.map(file => ImageCompress.getOrientation(file));\n        const readerPromises = files.map(file => ImageCompress.fileToDataURL(file));\n        let orientationsResult = [];\n        Promise.all(orientationPromises)\n            .then((orientations) => {\n            orientationsResult = orientations;\n            return Promise.all(readerPromises);\n        })\n            .then(readerResult => {\n            const resultArray = readerResult.map((parsedFile, index) => ({\n                image: parsedFile.dataUrl,\n                orientation: orientationsResult[index],\n                fileName: parsedFile.fileName,\n            }));\n            if (multiple) {\n                resolve(resultArray);\n            }\n            else {\n                resolve(resultArray[0]);\n            }\n        });\n    })\n        .catch(err => reject(err));\n});\nImageCompress.fileToDataURL = (file) => {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = (e) => {\n            //myReader.onloadend = (progressEvent: ProgressEvent<FileReader>)\n            resolve({ dataUrl: e.target.result, fileName: file.name });\n        };\n        try {\n            reader.readAsDataURL(file);\n        }\n        catch (e) {\n            reject(`ngx-image-compress - probably no file have been selected: ${e}`);\n        }\n    });\n};\nImageCompress.generateUploadInputRenderer = (render, multiple = true, rejectOnCancel = false) => {\n    let lock = false;\n    return new Promise((resolve, reject) => {\n        const inputElement = render.createElement('input');\n        render.setStyle(inputElement, 'display', 'none');\n        render.setProperty(inputElement, 'type', 'file');\n        render.setProperty(inputElement, 'accept', 'image/*');\n        if (multiple) {\n            render.setProperty(inputElement, 'multiple', 'true');\n        }\n        render.listen(inputElement, 'click', ($event) => {\n            $event.target.value = '';\n        });\n        render.listen(inputElement, 'change', $event => {\n            lock = true;\n            const files = $event.target.files;\n            resolve(files);\n        });\n        if (rejectOnCancel) {\n            window.addEventListener('focus', () => {\n                setTimeout(() => {\n                    if (!lock) {\n                        reject(new Error('file upload on blur - no file selected'));\n                    }\n                }, 300);\n            }, { once: true });\n        }\n        inputElement.click();\n    });\n};\nImageCompress.generateUploadInputNative = (documentNativeApi, multiple = true, rejectOnCancel = false) => {\n    let lock = false;\n    return new Promise((resolve, reject) => {\n        const inputElement = documentNativeApi.createElement('input');\n        inputElement.id = 'upload-input' + new Date();\n        inputElement.style.display = 'none';\n        inputElement.setAttribute('type', 'file');\n        inputElement.setAttribute('accept', 'image/*');\n        if (multiple) {\n            inputElement.setAttribute('multiple', 'true');\n        }\n        documentNativeApi.body.appendChild(inputElement);\n        inputElement.addEventListener('change', () => {\n            lock = true;\n            resolve(inputElement.files);\n            documentNativeApi.body.removeChild(documentNativeApi.getElementById(inputElement.id));\n        }, { once: true });\n        if (rejectOnCancel) {\n            window.addEventListener('focus', () => {\n                setTimeout(() => {\n                    if (!lock && documentNativeApi.getElementById(inputElement.id)) {\n                        reject(new Error('file upload on blur - no file selected'));\n                        documentNativeApi.body.removeChild(documentNativeApi.getElementById(inputElement.id));\n                    }\n                }, 300);\n            }, { once: true });\n        }\n        // open file select box\n        inputElement.click();\n    });\n};\nImageCompress.compress = (imageDataUrlSource, orientation, render, ratio = 50, quality = 50, maxwidth = 0, maxheight = 0) => new Promise(function (resolve, reject) {\n    quality = quality / 100;\n    ratio = ratio / 100;\n    const sourceImage = new Image();\n    // important for safari: we need to wait for onload event\n    sourceImage.onload = () => {\n        const canvas = render.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n            return reject(`No canvas context available`);\n        }\n        let w = sourceImage.naturalWidth;\n        let h = sourceImage.naturalHeight;\n        if (!CSS.supports('image-orientation', 'from-image')) {\n            if (orientation === DOC_ORIENTATION.Right || orientation === DOC_ORIENTATION.Left) {\n                const t = w;\n                w = h;\n                h = t;\n            }\n        }\n        const xratio = maxwidth ? maxwidth / w : 1;\n        const yratio = maxheight ? maxheight / h : 1;\n        ratio = Math.min(ratio, xratio, yratio);\n        canvas.width = w * ratio;\n        canvas.height = h * ratio;\n        const TO_RADIANS = Math.PI / 180;\n        if (CSS.supports('image-orientation', 'from-image') || orientation === DOC_ORIENTATION.Up) {\n            ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n        }\n        else if (orientation === DOC_ORIENTATION.Right) {\n            ctx.save();\n            ctx.rotate(90 * TO_RADIANS);\n            ctx.translate(0, -canvas.width);\n            ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n            ctx.restore();\n        }\n        else if (orientation === DOC_ORIENTATION.Left) {\n            ctx.save();\n            ctx.rotate(-90 * TO_RADIANS);\n            ctx.translate(-canvas.width, 0);\n            ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n            ctx.restore();\n        }\n        else if (orientation === DOC_ORIENTATION.Down) {\n            ctx.save();\n            ctx.rotate(180 * TO_RADIANS);\n            ctx.translate(-canvas.width, -canvas.height);\n            ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n            ctx.restore();\n        }\n        else {\n            // no orientation value found - same as default UP\n            ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n        }\n        const mime = imageDataUrlSource.substr(5, imageDataUrlSource.split(';')[0].length - 5);\n        // TODO test on mime\n        const result = canvas.toDataURL(mime, quality);\n        resolve(result);\n    };\n    sourceImage.onerror = e => reject(e);\n    sourceImage.src = imageDataUrlSource;\n});\nImageCompress.byteCount = (imgString) => encodeURI(imgString).split(/%..|./).length - 1;\nImageCompress.getImageMaxSize = async (maxSizeMb, debugMode, render, rejectOnCancel = false) => {\n    const MAX_TRIES = 10;\n    const bytesToMB = (bytes) => (bytes / 1024 / 1024).toFixed(2);\n    if (debugMode) {\n        console.debug('NgxImageCompress - Opening upload window');\n    }\n    const myFile = (await ImageCompress.uploadFile(render, false, rejectOnCancel));\n    let compressedFile;\n    for (let i = 0; i < MAX_TRIES; i++) {\n        const previousSize = ImageCompress.byteCount(myFile.image);\n        compressedFile = await ImageCompress.compress(myFile.image, myFile.orientation, render, 50, 100);\n        const newSize = ImageCompress.byteCount(compressedFile);\n        console.debug('NgxImageCompress -', 'Compression from', bytesToMB(previousSize), 'MB to', bytesToMB(newSize), 'MB');\n        if (newSize >= previousSize) {\n            if (i === 0) {\n                if (debugMode) {\n                    console.debug('NgxImageCompress -', \"File can't be reduced at all - returning the original\", bytesToMB(previousSize), 'MB large');\n                }\n                throw { ...myFile, image: compressedFile };\n            }\n            else {\n                if (debugMode) {\n                    console.debug('NgxImageCompress -', \"File can't be reduced more - returning the best we can, which is \", bytesToMB(previousSize), 'MB large');\n                }\n                throw { ...myFile, image: compressedFile };\n            }\n        }\n        else {\n            if (newSize < maxSizeMb * 1024 * 1024) {\n                if (debugMode) {\n                    console.debug('NgxImageCompress -', 'Here your file', bytesToMB(newSize), 'MB large');\n                }\n                return { ...myFile, image: compressedFile };\n            }\n            else if (i === 9) {\n                if (debugMode) {\n                    console.debug('NgxImageCompress -', \"File can't reach the desired size after\", MAX_TRIES, 'tries. Returning file ', bytesToMB(previousSize), 'MB large');\n                }\n                throw { ...myFile, image: compressedFile };\n            }\n        }\n        if (debugMode) {\n            console.debug('NgxImageCompress -', 'Reached', bytesToMB(newSize), 'MB large. Trying another time after', i + 1, 'times');\n        }\n        myFile.image = compressedFile;\n    }\n    if (debugMode) {\n        console.debug('NgxImageCompress - Unexpected error');\n    }\n    throw {};\n};\n\nclass NgxImageCompressService {\n    constructor(rendererFactory) {\n        this.DOC_ORIENTATION = DOC_ORIENTATION;\n        this.render = rendererFactory.createRenderer(null, null);\n    }\n    /**\n     * helper to evaluate the compression rate\n     * @param imgString the image in base64 string format\n     */\n    byteCount(image) {\n        return ImageCompress.byteCount(image);\n    }\n    /**\n     * Get the correct Orientation value from image tags\n     */\n    getOrientation(file) {\n        return ImageCompress.getOrientation(file);\n    }\n    /**\n     * return a promise with the new image data and image orientation\n     * Nothing happen if no file have been selected\n     */\n    uploadFile() {\n        return ImageCompress.uploadFile(this.render, false);\n    }\n    /**\n     * return a promise with an array of image data and image orientation\n     * Nothing happen if no files have been selected\n     */\n    uploadMultipleFiles() {\n        return ImageCompress.uploadFile(this.render, true);\n    }\n    /**\n     * return a promise with the new image data and image orientation\n     * the promise will reject if no file have been selected\n     */\n    uploadFileOrReject() {\n        return ImageCompress.uploadFile(this.render, false, true);\n    }\n    /**\n     * return a promise with an array of image data and image orientation\n     * the promise will reject if no files have been selected\n     */\n    uploadMultipleFilesOrReject() {\n        return ImageCompress.uploadFile(this.render, true, true);\n    }\n    /**\n   * perform a compression from the given DataUrl (string), provided by the uploadFile, or uploadMultipleFiles method\n   *\n   *\n   | Parameter   | Type   | Description                                                                       |\n   | ----------- | ------ | --------------------------------------------------------------------------------- |\n   | image       | string | DataUrl (string) representing the image                                           |\n   | orientation | number | EXIF Orientation value using the DOC_ORIENTATION enum value                       |\n   | ratio       | number | Maximum scale factor as a percentage (optional, default: 50) <sup>[1](#fn1)</sup> |\n   | quality     | number | JPEG quality factor as a percentage (optional, default: 50) <sup>[2](#fn2)</sup>  |\n   | maxwidth    | number | Maximum width in pixels if you need to resize (optional, default: 0 - no resize)  |\n   | maxheight   | number | Maximum height in pixels if you need to resize (optional, default: 0 - no resize) |\n   */\n    compressFile(image, orientation, ratio = 50, quality = 50, maxWidth = 0, maxHeight = 0) {\n        return ImageCompress.compress(image, orientation, this.render, ratio, quality, maxWidth, maxHeight);\n    }\n    /**\n     * Most simple function to use here.\n     * Perform an upload and return an image dataUrl (string format) with a maximum size, given in *MegaBytes*\n     * If the size can't be reached, the best that can be reached will be returned in promise *rejection*\n     * Put debugMode to true if you have some trouble to print some help using console.debug\n     */\n    uploadAndGetImageWithMaxSize(maxSizeMb = 1, debugMode = false, rejectOnCancel = false) {\n        return ImageCompress.getImageMaxSize(maxSizeMb, debugMode, this.render, rejectOnCancel)\n            .then(uploadResponse => uploadResponse.image)\n            .catch(e => {\n            throw e.image;\n        });\n    }\n    /**\n     * Same as before, but return more informations (file name...)\n     */\n    uploadAndGetImageWithMaxSizeAndMetas(maxSizeMb = 1, debugMode = false, rejectOnCancel = false) {\n        return ImageCompress.getImageMaxSize(maxSizeMb, debugMode, this.render, rejectOnCancel);\n    }\n}\nNgxImageCompressService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.1.2\", ngImport: i0, type: NgxImageCompressService, deps: [{ token: i0.RendererFactory2 }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxImageCompressService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.1.2\", ngImport: i0, type: NgxImageCompressService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.1.2\", ngImport: i0, type: NgxImageCompressService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.RendererFactory2 }]; } });\n\nclass NgxImageCaptureComponent {\n    constructor() {\n        this.imageCaptured = new EventEmitter();\n        this.errorCapture = new EventEmitter();\n        this.videoElement = null;\n        this.videoStream = ViewChild('video');\n        this.streamOpened = false;\n    }\n    startVideoCapture() {\n        this.streamOpened = true;\n        const constraints = {\n            audio: false,\n            video: {\n                width: { ideal: 1920 },\n                height: { ideal: 1080 },\n                facingMode: { ideal: 'user' },\n            },\n        };\n        navigator.mediaDevices\n            .getUserMedia(constraints)\n            .then(stream => {\n            this.videoStream = stream;\n            setTimeout(() => {\n                if (this.videoElement?.nativeElement) {\n                    this.videoElement.nativeElement.srcObject = stream;\n                }\n            }, 100);\n        })\n            .catch(error => {\n            this.errorCapture.emit(`Ngx Image Compress: Could not access the camera. ${error}`);\n            this.streamOpened = true;\n        });\n    }\n    acquireImage() {\n        const canvas = document.createElement('canvas');\n        const video = this.videoElement?.nativeElement;\n        if (!video) {\n            this.errorCapture.emit('Ngx Image Compress - Error in acquisition of video element.');\n            this.streamOpened = false;\n            return;\n        }\n        canvas.width = video.videoWidth;\n        canvas.height = video.videoHeight;\n        canvas.getContext('2d')?.drawImage(video, 0, 0);\n        const newImage = canvas.toDataURL('jpg', 95);\n        if (this.videoStream) {\n            this.videoStream.getVideoTracks().forEach(track => track.stop());\n        }\n        this.imageCaptured.emit(newImage);\n        this.streamOpened = false;\n    }\n}\nNgxImageCaptureComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.1.2\", ngImport: i0, type: NgxImageCaptureComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\nNgxImageCaptureComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"15.1.2\", type: NgxImageCaptureComponent, selector: \"ngx-image-capture\", outputs: { imageCaptured: \"imageCaptured\", errorCapture: \"errorCapture\" }, viewQueries: [{ propertyName: \"videoElement\", first: true, predicate: [\"video\"], descendants: true }], ngImport: i0, template: `\n        <span (click)=\"startVideoCapture()\" *ngIf=\"!streamOpened\">\n            <ng-content select=\"[openStreamBtn]\"></ng-content>\n        </span>\n        <span (click)=\"acquireImage()\" *ngIf=\"streamOpened\">\n            <ng-content select=\"[acquireImageBtn]\"></ng-content>\n        </span>\n        <video #video autoplay *ngIf=\"streamOpened\"></video>\n    `, isInline: true, dependencies: [{ kind: \"directive\", type: i1.NgIf, selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.1.2\", ngImport: i0, type: NgxImageCaptureComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-image-capture', template: `\n        <span (click)=\"startVideoCapture()\" *ngIf=\"!streamOpened\">\n            <ng-content select=\"[openStreamBtn]\"></ng-content>\n        </span>\n        <span (click)=\"acquireImage()\" *ngIf=\"streamOpened\">\n            <ng-content select=\"[acquireImageBtn]\"></ng-content>\n        </span>\n        <video #video autoplay *ngIf=\"streamOpened\"></video>\n    ` }]\n        }], propDecorators: { imageCaptured: [{\n                type: Output\n            }], errorCapture: [{\n                type: Output\n            }], videoElement: [{\n                type: ViewChild,\n                args: ['video']\n            }] } });\n\nclass NgxImageCaptureModule {\n}\nNgxImageCaptureModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.1.2\", ngImport: i0, type: NgxImageCaptureModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxImageCaptureModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.1.2\", ngImport: i0, type: NgxImageCaptureModule, declarations: [NgxImageCaptureComponent], imports: [CommonModule], exports: [NgxImageCaptureComponent] });\nNgxImageCaptureModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.1.2\", ngImport: i0, type: NgxImageCaptureModule, imports: [CommonModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.1.2\", ngImport: i0, type: NgxImageCaptureModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [NgxImageCaptureComponent],\n                    imports: [CommonModule],\n                    exports: [NgxImageCaptureComponent],\n                }]\n        }] });\n\n/*\n * Public API Surface of ngx-image-compress\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DOC_ORIENTATION, NgxImageCaptureComponent, NgxImageCaptureModule, NgxImageCompressService };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}